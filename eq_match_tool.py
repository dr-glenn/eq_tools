# Review EqCorrScan detection images and assign quality rating

# TODO: generate a table that displays number of events in region and number that have been evaluated.
# TODO: add a field to match_records.csv that tells us to skip anything generated by the template.
# TODO: if template is garbage, set detection quality to 0.

import sys
import os
from PyQt5 import QtCore,QtGui, QtWidgets
import matplotlib.pyplot as plt
from PyQt5.QtWidgets import QVBoxLayout
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
#import cartopy.crs as ccrs     # bummer, I can't install cartopy due to proj4 difficulties
from mpl_toolkits.basemap import Basemap
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from qt5_match import Ui_MainWindow
import datetime as dt
import numpy as np
import pandas as pd

from config import MATCH_RECORD_FILE,STATION_FILE,EV_REGION_FILE,DETECTION_PLOTS
from stations import Stations
from templates import EqTemplates
from matches import MatchImages
#from my_util import dt_match

IMAGE_DIR = DETECTION_PLOTS

# PushButton styles to indicate that button is depressed
# see: https://stackoverflow.com/questions/19508450/programmatically-toggle-a-python-pyqt-qpushbutton
ENABLE_STYLESHEET = """
    QPushButton {
        border: 1px solid #007a94;
        border-radius: 6px;
        color:#ffffff;
        background-color: #007a94;
        min-width: 80px;
        }
    QPushButton:pressed {
        background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                  stop: 0 #008aa6, stop: 1 #008aa6);
        }

    QPushButton:flat {
        border: none;
        }
"""
DISABLE_STYLESHEET = """
    QPushButton {
       border: 1px solid #808080;
       border-radius: 6px;
       color:#ffffff;
       background-color: #808080;
       min-width: 80px;
       }
   QPushButton:flat {
       border: none;
       }

"""
from functools import wraps
from time import time
# use as a decorator to time functions
def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('func:%r args:[%r, %r] took: %2.4f sec' % \
              (f.__name__, args, kw, te-ts))
        return result
    return wrap

def mapSetup(axes, bbox):
    '''
    Setup a map object, it's an instance of Basemap
    :param axes: returned from Figure
    :param bbox: tuple(tuple(lower-left long,lat), tuple(upper-right long, lat))
    :return: basemap
    '''
    # use low resolution coastlines.
    #map = Basemap(projection='merc',llcrnrlat=52, urcrnrlat=59, llcrnrlon=-162, urcrnrlon=-150, lat_ts=55, resolution='l', ax=axes)
    map = Basemap(projection='cyl',llcrnrlat=bbox[0][1], urcrnrlat=bbox[1][1],
                  llcrnrlon=bbox[0][0], urcrnrlon=bbox[1][0], resolution='l', ax=axes)
    # draw coastlines, country boundaries, fill continents.
    map.drawcoastlines(linewidth=0.25)
    map.drawcountries(linewidth=0.25)
    map.fillcontinents(color='coral',lake_color='aqua')
    # draw the edge of the map projection region (the projection limb)
    map.drawmapboundary(fill_color='aqua')
    # draw lat/lon grid lines every 1 degrees.
    map.drawmeridians(np.arange(200,210,1))
    map.drawparallels(np.arange(52,59,1))
    return map

# See https://www.pythonguis.com/tutorials/first-steps-qt-creator/
class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    '''
    This class handles all the UI. There are individual methods for nearly every button or other control.
    Radio buttons and some checkboxes are handled as a group. Some pushbuttons use lambda functions rather
    than defining a separate method for each button.
    '''
    def __init__(self, matchImages, stations, templates, **kwargs):
        super(MainWindow, self).__init__(**kwargs)
        self.setupUi(self)
        self.matchButtons = [None, self.saveNoMatchButton, self.saveNotGoodMatchButton, self.saveMaybeMatchButton, self.saveGoodMatchButton]
        self.templates = templates
        self.matchImages = matchImages
        self.stations = stations
        self.seenNum = 0    # how many images have we evaluated
        self.notSeenNum = 0 # how many images have we not evaluated
        self.viewSeen = False   # do not show images that have already been reviewed
        self.viewUnseen = True  # show images that have not yet been reviewed
        self.review_quality = [1,2,3,4]     # which quality designations to see when reviewing
        self.reviewMatch1.setChecked(True)
        self.reviewMatch2.setChecked(True)
        self.reviewMatch3.setChecked(True)
        self.reviewMatch4.setChecked(True)
        self.reviewButtonGroup = QtWidgets.QButtonGroup(self.centralwidget)
        self.reviewButtonGroup.addButton(self.viewAllRB)
        self.reviewButtonGroup.addButton(self.viewUnseenRB)
        self.reviewButtonGroup.addButton(self.viewSeenRB)
        # must initialize regionSelect pulldown before setupHandlers
        self.region_counts = self.matchImages.getRegionCounts()     # number of images for each region
        self.updateRegionSelect(self.region_counts)     # add regions to the select pulldown
        self.setRegionCountTable()      # create table that shows total/unseen images in each region

        ####### All GUI component setup should be completed before setupHandlers ########
        self.setupHandlers()
        # TODO: imageDir should not be here, we should be retrieving images from MatchImages class
        self.imageDir = matchImages.getImageDir()
        self.imgName = None
        self.map = None
        self.map_axes = None
        self.map_inset_axes = None
        print('call makeMapPlot')
        self.makeMapPlot()
        # Set the review radio buttons. This will also call changeRegion(), which will then call clickNext()
        if (self.region_counts['unseen']==0).all():
            # all regions have zero unseen images
            self.viewSeenRB.setChecked(True)  # initialize to only view seen images
            self.clickViewRB('seen')
        else:   # some unseen images
            self.viewUnseenRB.setChecked(True)  # initialize to only view unseen images
            self.clickViewRB('unseen')
        #self.clickNext()    # load first image

    def setupHandlers(self):
        self.nextButton.clicked.connect(self.clickNext)
        self.prevButton.clicked.connect(self.clickPrev)
        self.saveExitButton.clicked.connect(self.clickSaveExit)
        self.saveGoodMatchButton.clicked.connect(lambda: self.clickMatch(4))
        self.saveMaybeMatchButton.clicked.connect(lambda: self.clickMatch(3))
        self.saveNotGoodMatchButton.clicked.connect(lambda: self.clickMatch(2))
        self.saveNoMatchButton.clicked.connect(lambda: self.clickMatch(1))
        self.regionSelect.currentTextChanged.connect(self.changeRegion)
        #self.reviewCheckBox.stateChanged.connect(self.review)
        self.viewAllRB.clicked.connect(lambda: self.clickViewRB('all'))
        self.viewSeenRB.clicked.connect(lambda: self.clickViewRB('seen'))
        self.viewUnseenRB.clicked.connect(lambda: self.clickViewRB('unseen'))
        self.reviewMatch1.clicked.connect(self.clickReviewQuality)
        self.reviewMatch2.clicked.connect(self.clickReviewQuality)
        self.reviewMatch3.clicked.connect(self.clickReviewQuality)
        self.reviewMatch4.clicked.connect(self.clickReviewQuality)

    def clickReviewQuality(self):
        '''
        When reviewing image quality values, user can choose to review only some of the quality levels.
        Read all the checkboxes and filter the images that will be presented.
        :return:
        '''
        # read all the checkboxes
        self.review_quality = []
        if self.reviewMatch1.isChecked(): self.review_quality.append(1)
        if self.reviewMatch2.isChecked(): self.review_quality.append(2)
        if self.reviewMatch3.isChecked(): self.review_quality.append(3)
        if self.reviewMatch4.isChecked(): self.review_quality.append(4)
        self.changeRegion()

    def clickViewRB(self, value):
        print('clickViewRB: {}'.format(value))
        if value == 'all':
            self.viewSeen = True
            self.viewUnseen = True
        elif value == 'seen':
            self.viewSeen = True
            self.viewUnseen = False
        else:
            self.viewSeen = False
            self.viewUnseen = True
        self.changeRegion()

    def setRegionCountTable(self):
        self.regionTable.setHorizontalHeaderLabels(['region','total','unseen'])
        self.regionTable.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.updateRegionCountTable()

    def updateRegionCountTable(self):
        irow = 1
        for index, row in self.region_counts.iterrows():
            #region = row['region']
            self.regionTable.setItem(irow, 0, QtWidgets.QTableWidgetItem(index))
            total = row['total'] if not pd.isna(row['total']) else 0
            self.regionTable.setItem(irow, 1, QtWidgets.QTableWidgetItem(str(total)))
            unseen = row['unseen'] if not pd.isna(row['unseen']) else 0
            self.regionTable.setItem(irow, 2, QtWidgets.QTableWidgetItem(str(unseen)))
            irow += 1

    def changeRegionCount(self, region, decrement=True):
        '''
        When an image has been evaluated, the unseen count for the region should be decremented.
        :param region: region ID, typically a single character. Numbers are characters, not ints.
        :param decrement:
        :return:
        '''
        if decrement:
            self.region_counts.at[region, 'unseen'] = self.region_counts.at[region, 'unseen'] - 1
        self.updateRegionCountTable()

    def updateRegionSelect(self, rcount):
        '''
        Clear the regionSelect ComboBox and add only the regions that are currently found in the input image file.
        :param rcount: generated by tallyRegions, a Series whose index is 'region' with count of images in each region
        :return:
        '''
        self.regionSelect.clear()
        regions = ['All',]
        # TODO: need to add seen or unseen regions only?
        regions.extend(sorted(rcount.index.tolist()))
        print(regions)
        self.regionSelect.addItems(regions)

    def changeRegion(self):
        region = self.regionSelect.currentText()
        # filterRegion loads new DF and changes image index to -1
        self.files = self.matchImages.filterRegion(region, seen=self.viewSeen, unseen=self.viewUnseen, quality=self.review_quality)
        self.clickNext()

    def makeMapPlot(self, ax1=None):
        '''
        Map of the region. Displayed in a QtWidget
        :param ax1: matplotlib Axes object from a Figure
        :return:
        '''
        if not ax1:
            fig, ax1 = plt.subplots()
            self.plotWidget = FigureCanvas(fig)
            self.map_axes = ax1
            lay = QVBoxLayout()
            #lay.setContentsMargins(0, 0, 0, 0)
            lay.addWidget(self.plotWidget)
            self.mapWidget.setLayout(lay)
            #self.map_inset_axes = zoomed_inset_axes(self.map_axes, 6, loc=4)
            self.map_inset_axes = inset_axes(self.map_axes, width='50%', height='50%', loc='lower right')
            # xlim, ylim will change and must be set in mapMarker method
            #self.map_inset_axes.set_xlim()
            #self.map_inset_axes.set_ylim()
        # plot map
        # llcrnrlat=52, urcrnrlat=59, llcrnrlon=-162, urcrnrlon=-150
        bound_box = ((-162.0, 52.0),(-150.0, 59.0))
        self.map = mapSetup(self.map_axes, bound_box)

    @timing
    def mapMarker(self, location):
        '''
        Display a marker on the map. This redraws the entire map so that previous markers are not displayed.
        :param location: tuple of (longitude, latitude, depth)
        :return:
        '''
        #self.plotWidget.figure.clf()
        #self.plotWidget = None
        self.map_axes.clear()
        if self.map_inset_axes:
            self.map_inset_axes.clear()
        self.makeMapPlot(self.map_axes)
        # plot the stations first
        lons = self.stations.df['longitude'].tolist()
        lats = self.stations.df['latitude'].tolist()
        sta_names = self.stations.df['station'].tolist()
        sta_x,sta_y = self.map(lons, lats)
        if False:
            # nice idea, but you can't set the markersize!
            self.map.scatter(sta_x, sta_y, color='red', marker='^')
        else:
            for lon,lat in zip(sta_x,sta_y):
                self.map.plot(lon, lat, color='red', marker='^', markersize=2.0)
        # Now plot the event
        ev_x,ev_y = self.map(location[0], location[1])
        self.locationValue.setText('{:.4f}, {:.4f}'.format(location[0], location[1]))
        self.map.plot(ev_x, ev_y, 'bo', markersize=4.0)

        # map inset to zoom into location
        lon0 = location[0] - 1.0
        lon1 = location[0] + 1.0
        lat0 = location[1] - 1.0
        lat1 = location[1] + 1.0
        self.map_inset_axes.set_xlim(lon0, lon1)
        self.map_inset_axes.set_ylim(lat0, lat1)
        # resolution: c=crude, l=low, i=intermediate, h=high, f=full
        map2 = Basemap(llcrnrlon=lon0, urcrnrlon=lon1,
                       llcrnrlat=lat0, urcrnrlat=lat1,
                       projection='cyl', resolution='l', ax=self.map_inset_axes)
        # draw coastlines, country boundaries, fill continents.
        map2.drawcoastlines(linewidth=0.25)
        map2.drawcountries(linewidth=0.25)
        map2.fillcontinents(color='coral',lake_color='aqua')
        # draw the edge of the map projection region (the projection limb)
        map2.drawmapboundary(fill_color='aqua')
        #map2.drawmapboundary(fill_color='#7777ff')
        #map2.fillcontinents(color='#ddaa66', lake_color='#7777ff', zorder=0)
        #map2.drawcoastlines()
        #map2.drawcountries()
        # plot stations with labels
        for lon,lat,name in zip(sta_x, sta_y, sta_names):
            #map2.plot(lon, lat, color='red', marker='^')
            # kwargs are passed to Text object
            self.map_inset_axes.annotate(name, (lon, lat), color='red', fontsize='xx-small')
        map2.plot(ev_x, ev_y, 'bo', markersize=4.0)
        self.plotWidget.figure.canvas.draw()    # this refreshes the map and adds new marker

    def makeTestPlot(self):
        data = np.array([0.7, 0.7, 0.7, 0.8, 0.9, 0.9, 1.5, 1.5, 1.5, 1.5])
        fig, ax1 = plt.subplots()
        bins = np.arange(0.6, 1.62, 0.02)
        n1, bins1, patches1 = ax1.hist(data, bins, alpha=0.6, density=False, cumulative=False)
        # plot
        self.plotWidget = FigureCanvas(fig)
        lay = QVBoxLayout()
        #lay.setContentsMargins(0, 0, 0, 0)
        lay.addWidget(self.plotWidget)
        self.mapWidget.setLayout(lay)

    def clickSaveExit(self):
        '''
        store the last image we looked at, so we can resume later
        :return:
        '''
        # close the MainWindow, thereby exiting the app and closing the csvfile
        self.close()

    def clickMatch(self, value):
        # handler for any of the match quality buttons
        self.storeMatch(self.region, value, self.is_new)
        self.clickNext()

    @timing
    def storeMatch(self, region, quality, is_new):
        self.matchImages.saveMatch(self.imgName, self.templ_date, self.det_date, region, quality, is_new)
        self.changeRegionCount(region)

    def showDates(self, templ_date, det_date):
        # show the template and detection dates
        self.templateDateLabel.setText(templ_date.strftime('%Y-%m-%d %H:%M:%S'))
        self.matchDateLabel.setText(det_date.strftime('%Y-%m-%d %H:%M:%S'))

    @timing
    def _event_match_template(self, ev_date):
        return self.templates.find(ev_date)

    @timing
    def changeImage(self, imgName):
        #print('changeImage: {}'.format(imgName))
        self.filenameLabel.setText(imgName) # display the image filename
        # extract template date and detection date
        f,x = imgName.split('.')
        t,d = f.split('_')
        self.templ_date = dt.datetime.strptime(t[len('Templ-'):], '%Y-%m-%dT%H-%M-%S')
        self.det_date = dt.datetime.strptime(d[len('Det-'):], '%Y-%m-%dT%H-%M-%S')
        self.showDates(self.templ_date, self.det_date)
        # Now display the template match traces
        img_file = '{}/{}'.format(self.imageDir,imgName)
        if os.path.exists(img_file):
            self.showImage(img_file)
            # lookup the template to get its geographic location
            templ_data = self.templates.find(self.templ_date)
            #print(templ_data.iloc[0])
            ev = templ_data.iloc[0] # earthquake event data: lat-long, etc.
            detect_data = self._event_match_template(self.det_date)
            if not detect_data.empty:
                # detection event is also a template
                self.is_new = 0
                print('detection {} is also a template'.format(self.det_date))
                self.inCatalogValue.setText('event is a template')
                self.inCatalogValue.setStyleSheet('color: red')
                if detect_data.shape[0] > 1:
                    print('WARNING: detection matches more than one template? num={}'.format(detect_data.shape[0]))
                    for i in range(detect_data.shape[0]):
                        print('... {}'.format(detect_data.iloc[i]))
            else:
                self.is_new = 1
                print('detection {} is not a template'.format(self.det_date))
                self.inCatalogValue.setText('event is new')
                self.inCatalogValue.setStyleSheet('color: green')
            # display the template location on a map
            location = (ev['longitude'], ev['latitude'], ev['depth'])
            self.region = str(ev['region'])
            self.evRegionValue.setText('{}'.format(self.region))
            self.magnitudeValue.setText('{:.1f}'.format(ev['mag']))
            self.mapMarker(location)
        else:
            print('{} not found'.format(imgName))
            self.messageBox.setText('image not found, click Next')
            self.messageBox.setStyleSheet('color: red')
        #print('changeImage: END')

    # TODO: if user clicks Prev or Next button, they want to review existing quality matches and not skip to next un-reviewed
    def clickPrev(self, button_click=False):
        '''
        Load previous image. Definition of previous depends on value of button_click.
        :param button_click: If True, user clicked button in UI. If False, this was called by another method.
        :return:
        '''
        #print('clickPrev: start')
        df = self.matchImages.getPrev()
        # TODO: must note if this is unseen or a review. Do not change region if review.
        if df.empty:
            print('clickPrev: empty df: reset to All regions')
            self.messageBox.setText('Reset to All: no more images in current region')
            self.regionSelect.setCurrentIndex(0)
        else:
            self.messageBox.setText('')
            self.imgName = df['filename']
            print('clickPrev: {}'.format(self.imgName))
            self.changeImage(self.imgName)
            self.setQualityButton(df['quality'])

    def clickNext(self, button_click=False):
        '''
        Load next image. Definition of next depends on value of button_click.
        If button_click==True, show next image even if already evaluated.
        If button_click==False, skip to next unevaluated image.
        :param button_click: If True, user clicked button in UI. If False, this was called by another method.
        :return:
        '''
        #print('clickNext: start')
        df = self.matchImages.getNext(view_seen=self.viewSeen, view_unseen=self.viewUnseen)
        # TODO: must note if this is unseen or a review. Do not change region if review.
        if df.empty:
            print('clickNext: empty df: reset to All regions')
            self.messageBox.setText('Reset to All: no more images in current region')
            self.regionSelect.setCurrentIndex(0)
            # if there are no more new images to view, then switch to review All
            if (self.region_counts['unseen']==0).all():
                # all regions have zero unseen images
                self.viewSeenRB.setChecked(True)  # initialize to only view seen images
                self.clickViewRB('seen')
        else:
                self.messageBox.setText('')
                self.imgName = df['filename']
                print('clickNext: {}'.format(self.imgName))
                self.changeImage(self.imgName)
                self.setQualityButton(df['quality'])

    def setQualityButton(self, value):
        # first make all buttons appear disabled
        for button in self.matchButtons:
            if button:
                button.setStyleSheet(DISABLE_STYLESHEET)
        if value == -1:
            return
        else:
            # reviewing an already evaluated image, so set the value button state
            if value == 4:
                self.saveGoodMatchButton.setStyleSheet(ENABLE_STYLESHEET)
            elif value == 3:
                self.saveMaybeMatchButton.setStyleSheet(ENABLE_STYLESHEET)
            elif value == 2:
                self.saveNotGoodMatchButton.setStyleSheet(ENABLE_STYLESHEET)
            elif value == 1:
                self.saveNoMatchButton.setStyleSheet(ENABLE_STYLESHEET)

    @timing
    def showImage(self, image_name):
        image_profile = QtGui.QImage(image_name)
        img_geom = self.image.geometry()
        image_profile = image_profile.scaled(img_geom.width(),img_geom.height(),
                                             aspectRatioMode=QtCore.Qt.KeepAspectRatio,
                                             transformMode=QtCore.Qt.SmoothTransformation) # To scale image for example and keep its Aspect Ration
        self.image.setPixmap(QtGui.QPixmap.fromImage(image_profile))

if __name__ == "__main__":
    stations = Stations()
    templates = EqTemplates()
    matchImages = MatchImages(IMAGE_DIR, templates, MATCH_RECORD_FILE)
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow(matchImages, stations, templates)
    window.show()
    retval = app.exec_()
    print('Exiting: {}'.format(retval))
    matchImages.save()
    sys.exit(retval)
