# Review EqCorrScan detection images and assign quality rating

# TODO: generate a table that displays number of events in region and number that have been evaluated.
# TODO: add a field to match_records.csv that tells us to skip anything generated by the template.
# TODO: if template is garbage, set detection quality to 0.

import sys
import os
from PyQt5 import QtCore,QtGui, QtWidgets
import matplotlib.pyplot as plt
from PyQt5.QtWidgets import QVBoxLayout
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
#import cartopy.crs as ccrs     # bummer, I can't install cartopy due to proj4 difficulties
from mpl_toolkits.basemap import Basemap
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from qt5_match import Ui_MainWindow
import datetime as dt
import numpy as np
import pandas as pd

from config import MATCH_RECORD_FILE,STATION_FILE,EV_REGION_FILE,DETECTION_PLOTS
from stations import Stations
from templates import EqTemplates
from my_util import dt_match

IMAGE_DIR = DETECTION_PLOTS

# PushButton styles to indicate that button is depressed
# see: https://stackoverflow.com/questions/19508450/programmatically-toggle-a-python-pyqt-qpushbutton
ENABLE_STYLESHEET = """
    QPushButton {
        border: 1px solid #007a94;
        border-radius: 6px;
        color:#ffffff;
        background-color: #007a94;
        min-width: 80px;
        }
    QPushButton:pressed {
        background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                                  stop: 0 #008aa6, stop: 1 #008aa6);
        }

    QPushButton:flat {
        border: none;
        }
"""
DISABLE_STYLESHEET = """
    QPushButton {
       border: 1px solid #808080;
       border-radius: 6px;
       color:#ffffff;
       background-color: #808080;
       min-width: 80px;
       }
   QPushButton:flat {
       border: none;
       }

"""

from functools import wraps
from time import time
# use as a decorator to time functions
def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('func:%r args:[%r, %r] took: %2.4f sec' % \
              (f.__name__, args, kw, te-ts))
        return result
    return wrap

class MatchImages:
    '''
    Images have filenames like this: Templ-2018-11-17T03-53-30_Det-2018-05-08T14-24-02.png.
    The template datetime can be used to lookup template event info in an earthquake event file,
    such as QML or CSV file. The detection datetime can be used to determine if this is an existing event
    (it is found in the event file) or if it is a new event. Also detection datetimes can be used
    to construct a Family - events that are matches to a template.
    This class contains df (Pandas DataFrame) with templ_dt and region as columns.
    Method _findRegion will lookup the region by searching EqTemplates object.
    '''
    def __init__(self, path, templates, match_file=MATCH_RECORD_FILE):
        self.imageDir = path
        self.templates = templates  # object of class EqTemplates
        self.match_file = match_file
        self.region_count = pd.DataFrame()
        self.index = -1 # row index in self.df
        self.region = 'All'
        self.savefile = False
        if not os.path.isfile(match_file):
            print('ERROR: {} must be created by gen_csv.py'.format(match_file))
            sys.exit(1)

        # self.df has regions assigned to each image and columns for 'quality' and 'is_new'
        # quality ranges from 1 to 4 (best) or -1 if detection image has not been evaluated
        # is_new =0 if the detected event is another template, =1 if it is new, or -1 if not yet evaluated
        self.df = self.readFile(match_file)
        self.df_select = self.df     # this will be the working view of self.df
        self.image_files = []
        print('MatchImages: {} images before removeSeen'.format(self.df.shape[0]))
        # select images that do not yet have 'quality' assigned
        self.removeSeen()
        print('MatchImages: {} images'.format(len(self.image_files)))
        self.tallyRegions()

    def save(self):
        if self.savefile:
            self.df.to_csv(self.match_file, index=False)
            print('MatchImages.save: updating file {}'.format(self.match_file))
        else:
            print('MatchImages.save: no update to {}'.format(self.match_file))

    @classmethod
    def parseImageFilename(cls, imgName):
        # extract template date and detection date
        f,x = imgName.split('.')
        t,d = f.split('_')
        templ_date = dt.datetime.strptime(t[len('Templ-'):], '%Y-%m-%dT%H-%M-%S')
        det_date = dt.datetime.strptime(d[len('Det-'):], '%Y-%m-%dT%H-%M-%S')
        return templ_date,det_date

    def exclude_self(self, time_diff_sec=30):
        '''
        Remove self-detection images: a template matches itself
        '''
        time_diff = dt.timedelta(seconds=time_diff_sec) # seconds
        print('exclude_self:')
        print('self.df has {} rows'.format(self.df.shape[0]))
        self.df = self.df[~self.df.apply(lambda x: dt_match(x['templ_dt'], x['det_dt'], time_diff), axis=1)]
        print('self.df has {} rows'.format(self.df.shape[0]))

    def readFile(self, file):
        date_cols = ['templ_dt', 'det_dt']
        df = pd.read_csv(file, dtype={'region':'string'}, parse_dates=date_cols)
        return df

    @timing
    def _findRegions(self, templates):
        # Match all image filenames with assigned region for the template
        # compare columns in 2 DF for matches: https://datascience.stackexchange.com/questions/33053/how-do-i-compare-columns-in-different-data-frames
        #print(self.df)
        cnt = 1
        # TODO: need vast improvement in speed
        # both templates and this use DF sorted by templ_dt
        # iterate over rows of self.df
        # lookup in templates.df, but don't use Pandas, instead just use a generator to find first match
        # when match is found, assign the region to current row.
        # no step forward in self.df, continue to assign region until row['templ_dt'] is different
        tdt = None
        for index,row in self.df.iterrows():
            if cnt % 250 == 0:
                print('findRegions: {}'.format(cnt))
            cnt += 1
            try:
                templ_dt = row['templ_dt']
                if tdt and templ_dt == tdt:
                    # we already have the template that matches this event
                    # don't waste time with templates.find()
                    #print('cnt={}, dt={}'.format(cnt,templ_dt))
                    pass
                else:
                    match = templates.find(templ_dt)  # return a DF of record from EV_SELECTED_REGION
                    print('new match at {}, dt={}'.format(cnt,match.iloc[0]['templ_dt']))
                tdt = templ_dt
                if not match.empty:
                    region = match.iloc[0]['region']
                    if not region in self.regionLookup:
                        self.regionLookup[region] = list()
                    self.regionLookup[region].append(row['filename'])
            except:
                print('ERROR in _findRegions: file={}'.format(row['filename']))

    def tallyRegions(self):
        '''
        Count of image files in each region. Fills a DataFrame with counts of all images in each region
        and unseen images in each.
        :return:
        '''
        # TODO: add a count of evaluated files
        # region_count is a Series, number of images in each region
        region_count = self.df['region'].value_counts()
        region_count.rename('total', inplace=True)
        print('Region\tCount\n{}'.format(region_count))
        # if review checkbox is off, df_select is only images not yet evaluated.
        # if review checkbox is on, df_select is all images.
        # TODO: next two lines should only be one. Figure out about chained indexing.
        unseen_df = self.df[self.df['quality'] == -1]
        unseen_count = unseen_df['region'].value_counts()
        unseen_count.rename('unseen', inplace=True)
        # TODO: add a row for 'All' regions
        print('Unseen\nRegion\tCount\n{}'.format(unseen_count))
        self.region_count = pd.concat([region_count, unseen_count], axis=1)

    def getRegionCounts(self):
        '''
        region_count index is the region name, columns are number of images: 'total' and 'unseen'
        :return: DataFrame populated by method tallyRegions
        '''
        if self.region_count.empty:
            self.tallyRegions()
        return self.region_count

    def getImageDir(self):
        return self.imageDir

    def removeSeen(self, seen=True, unseen=True):
        '''
        Remove some image files from list if they've been seen or not.
        Modifies self.image_files
        :param seen: if True, keep seen images, remove if False (inverse of expected behavior)
        :param unseen: if True, keep unseen images, remove if False (inverse of expected behavior)
        :return:
        '''
        if seen and unseen:     # keep all images
            self.df_select = self.df
        elif unseen:    # keep only unseen images
            self.df_select = self.df[self.df['quality'] == -1]
        else:           # keep only seen images
            self.df_select = self.df[self.df['quality'] != -1]
        print('removeSeen: seen={}, unseen={}, # images = {}'.format(seen, unseen, self.df_select.shape[0]))
        self.image_files = self.df_select['filename'].tolist()

    def filterRegion(self, region='All', seen=False, unseen=True, quality=None):
        '''
        Remove image files from list unless they match the region parameter.
        Region parameter is found in EqTemplates.
        :param region: 'All' or other values, '0' to '7' for Shumagin study
        :param unseen: True: only show images not yet reviewed; False: review all images
        :param quality: list of quality match values for review. If None, then review all images.
        :return:
        '''
        # TODO: should probably have a single method for filter that combines both region and 'seen'
        # modifies self.image_files
        self.removeSeen(seen=seen, unseen=unseen)
        self.index = -1
        if region == 'All':
            self.df_select = self.df
        else:
            self.df_select = self.df[self.df['region'] == region]
        # filter quality assessments when reviewing
        if seen and quality:
            # quality is a list of integers that we will review. 1 is no match, 4 is excellent match.
            if unseen:  # if also looking at unseen images, must add -1 to quality list
                quality.append(-1)
            self.df_select = self.df_select[self.df_select['quality'].isin(quality)]
        files = self.df_select['filename'].tolist()
        # self.image_files is list of all files that have not been reviewed for quality
        # files is list of all files in the region, regardless of review status
        # use set intersection to get only image_files in region that have not been reviewed
        files = set(self.image_files) & set(files)
        print('filterRegion: {} has {} images'.format(region, len(files)))
        self.image_files = sorted(list(files))
        return self.image_files

    def getFiles(self):
        return self.image_files

    def saveMatch(self, match_file, templ_date, det_date, region, quality, is_new):
        '''
        Stores our evaluation of the match quality in DataFrame.
        Also adds the match_file name to internal list so that we know we've seen it during this session.
        :param match_file: filename of match image file
        :param templ_date: date of the template (also embedded in the filename)
        :param det_date: date of the detection (also embedded in the filename)
        :param region: designation for the region that the template is located in
        :param quality: evaluated quality of detection, a number from 1 to 4
        :param is_new: False: if detection is another template that we already have.
        :return:
        '''
        #print('saveMatch: {},{},{},{},{},{}'.format(match_file,templ_date,det_date,region,quality,is_new))
        self.savefile = True
        tstr = templ_date.strftime('%Y-%m-%d %H:%M:%S')
        dstr = det_date.strftime('%Y-%m-%d %H:%M:%S')
        match = {'file':match_file,'templ_date':tstr,'detect_date':dstr,'quality':quality,'is_new':is_new,'region':region}
        # TODO: why am I updating both df_select and df?
        self.df_select.iloc[self.index, self.df_select.columns.get_loc('is_new')] = is_new
        self.df_select.iloc[self.index, self.df_select.columns.get_loc('quality')] = quality
        self.df.iloc[self.df['filename']==match_file, self.df_select.columns.get_loc('is_new')] = is_new
        self.df.iloc[self.df['filename']==match_file, self.df_select.columns.get_loc('quality')] = quality
        print('saveMatch: {}'.format(self.df_select.iloc[self.index]))

    def getNext(self, view_seen=False, view_unseen=True):
        '''
        # TODO: not using parameter view_unseen, but you should
        If view_seen==True, then get next image whether already seen or not.
        If view_seen==False, then only get next unseen image.
        If we've reached end of df_select, then return empty DF and let caller decide what to do.
        :param view_seen: return next image that has already been seen
        :param view_unseen: return next image that has not yet been seen
        :return: DataFrame where first row contains the image data or empty DF if none.
        '''
        self.index += 1
        retval = pd.DataFrame()     # empty DF
        nimage = self.df_select.shape[0]
        print('getNext: index={}, total={}'.format(self.index,nimage))
        if self.index >= nimage:
            print('getNext: no more images in current region, start at zero')
            self.index = 0
            # retval is empty DataFrame
        if view_seen:
            # get next image that has been reviewed or not
            retval = self.df_select.iloc[self.index]
        else:
            # look for next image that has not yet been reviewed
            while self.index < nimage:
                #print(self.df_select.iloc[self.index]['quality'])
                if self.df_select.iloc[self.index]['quality'] == -1:
                    retval = self.df_select.iloc[self.index]
                    break
                self.index += 1
        # if retval==df.empty, we've reached the end, caller of getNext must do something special
        return retval

    def getPrev(self, view_seen=False, view_unseen=True):
        '''
        See comments for getNext method.
        :param view_seen:
        :param view_unseen:
        :return:
        '''
        self.index -= 1
        # TODO: must test index for end of DF
        retval = pd.DataFrame()     # empty DF
        # skip to next unseen
        nimage = self.df_select.shape[0]
        print('getPrev: index={}, total={}'.format(self.index,nimage))
        if self.index < 0:
            print('getPrev: wrap around to last image')
            self.index = nimage-1
            # retval is empty DataFrame
        if view_seen:
            # get next image that has been reviewed or not
            retval = self.df_select.iloc[self.index]
        else:
            # look for next image that has not yet been reviewed
            while self.index >= 0:
                #print(self.df_select.iloc[self.index]['quality'])
                if self.df_select.iloc[self.index]['quality'] == -1:
                    retval = self.df_select.iloc[self.index]
                    break
                self.index -= 1
        # if retval==df.empty, we've reached the end, caller of getPrev must do something special
        return retval

def mapSetup(axes, bbox):
    '''
    Setup a map object, it's an instance of Basemap
    :param axes: returned from Figure
    :param bbox: tuple(tuple(lower-left long,lat), tuple(upper-right long, lat))
    :return: basemap
    '''
    # use low resolution coastlines.
    #map = Basemap(projection='merc',llcrnrlat=52, urcrnrlat=59, llcrnrlon=-162, urcrnrlon=-150, lat_ts=55, resolution='l', ax=axes)
    map = Basemap(projection='cyl',llcrnrlat=bbox[0][1], urcrnrlat=bbox[1][1],
                  llcrnrlon=bbox[0][0], urcrnrlon=bbox[1][0], resolution='l', ax=axes)
    # draw coastlines, country boundaries, fill continents.
    map.drawcoastlines(linewidth=0.25)
    map.drawcountries(linewidth=0.25)
    map.fillcontinents(color='coral',lake_color='aqua')
    # draw the edge of the map projection region (the projection limb)
    map.drawmapboundary(fill_color='aqua')
    # draw lat/lon grid lines every 1 degrees.
    map.drawmeridians(np.arange(200,210,1))
    map.drawparallels(np.arange(52,59,1))
    return map

# See https://www.pythonguis.com/tutorials/first-steps-qt-creator/
class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self, matchImages, stations, templates, **kwargs):
        super(MainWindow, self).__init__(**kwargs)
        self.setupUi(self)
        self.matchButtons = [None, self.saveNoMatchButton, self.saveNotGoodMatchButton, self.saveMaybeMatchButton, self.saveGoodMatchButton]
        self.templates = templates
        self.matchImages = matchImages
        self.stations = stations
        self.seenNum = 0    # how many images have we evaluated
        self.notSeenNum = 0 # how many images have we not evaluated
        self.viewSeen = False   # do not show images that have already been reviewed
        self.viewUnseen = True  # show images that have not yet been reviewed
        self.review_quality = [1,2,3,4]     # which quality designations to see when reviewing
        self.reviewMatch1.setChecked(True)
        self.reviewMatch2.setChecked(True)
        self.reviewMatch3.setChecked(True)
        self.reviewMatch4.setChecked(True)
        self.reviewButtonGroup = QtWidgets.QButtonGroup(self.centralwidget)
        self.reviewButtonGroup.addButton(self.viewAllRB)
        self.reviewButtonGroup.addButton(self.viewUnseenRB)
        self.reviewButtonGroup.addButton(self.viewSeenRB)
        # must initialize regionSelect pulldown before setupHandlers
        self.region_counts = self.matchImages.getRegionCounts()     # number of images for each region
        self.updateRegionSelect(self.region_counts)     # add regions to the select pulldown
        self.setRegionCountTable()      # create table that shows total/unseen images in each region
        ####### All GUI component setup should be completed before setupHandlers ########
        self.setupHandlers()
        # TODO: imageDir should not be here, we should be retrieving images from MatchImages class
        self.imageDir = matchImages.getImageDir()
        self.imgName = None
        self.map = None
        self.map_axes = None
        self.map_inset_axes = None
        print('call makeMapPlot')
        self.makeMapPlot()
        # Set the review radio buttons. This will also call changeRegion(), which will then call clickNext()
        if (self.region_counts['unseen']==0).all():
            # all regions have zero unseen images
            self.viewSeenRB.setChecked(True)  # initialize to only view seen images
            self.clickViewRB('seen')
        else:   # some unseen images
            self.viewUnseenRB.setChecked(True)  # initialize to only view unseen images
            self.clickViewRB('unseen')
        #self.clickNext()    # load first image

    def setupHandlers(self):
        self.nextButton.clicked.connect(self.clickNext)
        self.prevButton.clicked.connect(self.clickPrev)
        self.saveExitButton.clicked.connect(self.clickSaveExit)
        self.saveGoodMatchButton.clicked.connect(lambda: self.clickMatch(4))
        self.saveMaybeMatchButton.clicked.connect(lambda: self.clickMatch(3))
        self.saveNotGoodMatchButton.clicked.connect(lambda: self.clickMatch(2))
        self.saveNoMatchButton.clicked.connect(lambda: self.clickMatch(1))
        self.regionSelect.currentTextChanged.connect(self.changeRegion)
        #self.reviewCheckBox.stateChanged.connect(self.review)
        self.viewAllRB.clicked.connect(lambda: self.clickViewRB('all'))
        self.viewSeenRB.clicked.connect(lambda: self.clickViewRB('seen'))
        self.viewUnseenRB.clicked.connect(lambda: self.clickViewRB('unseen'))
        self.reviewMatch1.clicked.connect(self.clickReviewQuality)
        self.reviewMatch2.clicked.connect(self.clickReviewQuality)
        self.reviewMatch3.clicked.connect(self.clickReviewQuality)
        self.reviewMatch4.clicked.connect(self.clickReviewQuality)

    def clickReviewQuality(self):
        '''
        When reviewing image quality values, user can choose to review only some of the quality levels.
        Read all the checkboxes and filter the images that will be presented.
        :return:
        '''
        # read all the checkboxes
        self.review_quality = []
        if self.reviewMatch1.isChecked(): self.review_quality.append(1)
        if self.reviewMatch2.isChecked(): self.review_quality.append(2)
        if self.reviewMatch3.isChecked(): self.review_quality.append(3)
        if self.reviewMatch4.isChecked(): self.review_quality.append(4)
        self.changeRegion()

    def clickViewRB(self, value):
        print('clickViewRB: {}'.format(value))
        if value == 'all':
            self.viewSeen = True
            self.viewUnseen = True
        elif value == 'seen':
            self.viewSeen = True
            self.viewUnseen = False
        else:
            self.viewSeen = False
            self.viewUnseen = True
        self.changeRegion()

    def setRegionCountTable(self):
        self.regionTable.setHorizontalHeaderLabels(['region','total','unseen'])
        self.regionTable.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        self.updateRegionCountTable()

    def updateRegionCountTable(self):
        irow = 1
        for index, row in self.region_counts.iterrows():
            #region = row['region']
            self.regionTable.setItem(irow, 0, QtWidgets.QTableWidgetItem(index))
            total = row['total'] if not pd.isna(row['total']) else 0
            self.regionTable.setItem(irow, 1, QtWidgets.QTableWidgetItem(str(total)))
            unseen = row['unseen'] if not pd.isna(row['unseen']) else 0
            self.regionTable.setItem(irow, 2, QtWidgets.QTableWidgetItem(str(unseen)))
            irow += 1

    def changeRegionCount(self, region, decrement=True):
        '''
        When an image has been evaluated, the unseen count for the region should be decremented.
        :param region: region ID, typically a single character. Numbers are characters, not ints.
        :param decrement:
        :return:
        '''
        if decrement:
            self.region_counts.at[region, 'unseen'] = self.region_counts.at[region, 'unseen'] - 1
        self.updateRegionCountTable()

    def updateRegionSelect(self, rcount):
        '''
        Clear the regionSelect ComboBox and add only the regions that are currently found in the input image file.
        :param rcount: generated by tallyRegions, a Series whose index is 'region' with count of images in each region
        :return:
        '''
        self.regionSelect.clear()
        regions = ['All',]
        # TODO: need to add seen or unseen regions only?
        regions.extend(sorted(rcount.index.tolist()))
        print(regions)
        self.regionSelect.addItems(regions)

    def changeRegion(self):
        region = self.regionSelect.currentText()
        # filterRegion loads new DF and changes image index to -1
        self.files = self.matchImages.filterRegion(region, seen=self.viewSeen, unseen=self.viewUnseen, quality=self.review_quality)
        self.clickNext()

    def makeMapPlot(self, ax1=None):
        '''
        Map of the region. Displayed in a QtWidget
        :param ax1: matplotlib Axes object from a Figure
        :return:
        '''
        if not ax1:
            fig, ax1 = plt.subplots()
            self.plotWidget = FigureCanvas(fig)
            self.map_axes = ax1
            lay = QVBoxLayout()
            #lay.setContentsMargins(0, 0, 0, 0)
            lay.addWidget(self.plotWidget)
            self.mapWidget.setLayout(lay)
            #self.map_inset_axes = zoomed_inset_axes(self.map_axes, 6, loc=4)
            self.map_inset_axes = inset_axes(self.map_axes, width='50%', height='50%', loc='lower right')
            # xlim, ylim will change and must be set in mapMarker method
            #self.map_inset_axes.set_xlim()
            #self.map_inset_axes.set_ylim()
        # plot map
        # llcrnrlat=52, urcrnrlat=59, llcrnrlon=-162, urcrnrlon=-150
        bound_box = ((-162.0, 52.0),(-150.0, 59.0))
        self.map = mapSetup(self.map_axes, bound_box)

    @timing
    def mapMarker(self, location):
        '''
        Display a marker on the map. This redraws the entire map so that previous markers are not displayed.
        :param location: tuple of (longitude, latitude, depth)
        :return:
        '''
        #self.plotWidget.figure.clf()
        #self.plotWidget = None
        self.map_axes.clear()
        if self.map_inset_axes:
            self.map_inset_axes.clear()
        self.makeMapPlot(self.map_axes)
        # plot the stations first
        lons = self.stations.df['longitude'].tolist()
        lats = self.stations.df['latitude'].tolist()
        sta_names = self.stations.df['station'].tolist()
        sta_x,sta_y = self.map(lons, lats)
        if False:
            # nice idea, but you can't set the markersize!
            self.map.scatter(sta_x, sta_y, color='red', marker='^')
        else:
            for lon,lat in zip(sta_x,sta_y):
                self.map.plot(lon, lat, color='red', marker='^', markersize=2.0)
        # Now plot the event
        ev_x,ev_y = self.map(location[0], location[1])
        self.locationValue.setText('{:.4f}, {:.4f}'.format(location[0], location[1]))
        self.map.plot(ev_x, ev_y, 'bo', markersize=4.0)

        # map inset to zoom into location
        lon0 = location[0] - 1.0
        lon1 = location[0] + 1.0
        lat0 = location[1] - 1.0
        lat1 = location[1] + 1.0
        self.map_inset_axes.set_xlim(lon0, lon1)
        self.map_inset_axes.set_ylim(lat0, lat1)
        # resolution: c=crude, l=low, i=intermediate, h=high, f=full
        map2 = Basemap(llcrnrlon=lon0, urcrnrlon=lon1,
                       llcrnrlat=lat0, urcrnrlat=lat1,
                       projection='cyl', resolution='l', ax=self.map_inset_axes)
        # draw coastlines, country boundaries, fill continents.
        map2.drawcoastlines(linewidth=0.25)
        map2.drawcountries(linewidth=0.25)
        map2.fillcontinents(color='coral',lake_color='aqua')
        # draw the edge of the map projection region (the projection limb)
        map2.drawmapboundary(fill_color='aqua')
        #map2.drawmapboundary(fill_color='#7777ff')
        #map2.fillcontinents(color='#ddaa66', lake_color='#7777ff', zorder=0)
        #map2.drawcoastlines()
        #map2.drawcountries()
        # plot stations with labels
        for lon,lat,name in zip(sta_x, sta_y, sta_names):
            #map2.plot(lon, lat, color='red', marker='^')
            # kwargs are passed to Text object
            self.map_inset_axes.annotate(name, (lon, lat), color='red', fontsize='xx-small')
        map2.plot(ev_x, ev_y, 'bo', markersize=4.0)
        self.plotWidget.figure.canvas.draw()    # this refreshes the map and adds new marker

    def makeTestPlot(self):
        data = np.array([0.7, 0.7, 0.7, 0.8, 0.9, 0.9, 1.5, 1.5, 1.5, 1.5])
        fig, ax1 = plt.subplots()
        bins = np.arange(0.6, 1.62, 0.02)
        n1, bins1, patches1 = ax1.hist(data, bins, alpha=0.6, density=False, cumulative=False)
        # plot
        self.plotWidget = FigureCanvas(fig)
        lay = QVBoxLayout()
        #lay.setContentsMargins(0, 0, 0, 0)
        lay.addWidget(self.plotWidget)
        self.mapWidget.setLayout(lay)

    def clickSaveExit(self):
        '''
        store the last image we looked at, so we can resume later
        :return:
        '''
        # close the MainWindow, thereby exiting the app and closing the csvfile
        self.close()

    def clickMatch(self, value):
        # handler for any of the match quality buttons
        self.storeMatch(self.region, value, self.is_new)
        self.clickNext()

    @timing
    def storeMatch(self, region, quality, is_new):
        self.matchImages.saveMatch(self.imgName, self.templ_date, self.det_date, region, quality, is_new)
        self.changeRegionCount(region)

    def showDates(self, templ_date, det_date):
        # show the template and detection dates
        self.templateDateLabel.setText(templ_date.strftime('%Y-%m-%d %H:%M:%S'))
        self.matchDateLabel.setText(det_date.strftime('%Y-%m-%d %H:%M:%S'))

    @timing
    def _event_match_template(self, ev_date):
        return self.templates.find(ev_date)

    @timing
    def changeImage(self, imgName):
        #print('changeImage: {}'.format(imgName))
        self.filenameLabel.setText(imgName) # display the image filename
        # extract template date and detection date
        f,x = imgName.split('.')
        t,d = f.split('_')
        self.templ_date = dt.datetime.strptime(t[len('Templ-'):], '%Y-%m-%dT%H-%M-%S')
        self.det_date = dt.datetime.strptime(d[len('Det-'):], '%Y-%m-%dT%H-%M-%S')
        self.showDates(self.templ_date, self.det_date)
        # Now display the template match traces
        img_file = '{}/{}'.format(self.imageDir,imgName)
        if os.path.exists(img_file):
            self.showImage(img_file)
            # lookup the template to get its geographic location
            templ_data = self.templates.find(self.templ_date)
            #print(templ_data.iloc[0])
            ev = templ_data.iloc[0] # earthquake event data: lat-long, etc.
            detect_data = self._event_match_template(self.det_date)
            if not detect_data.empty:
                # detection event is also a template
                self.is_new = 0
                print('detection {} is also a template'.format(self.det_date))
                self.inCatalogValue.setText('event is a template')
                self.inCatalogValue.setStyleSheet('color: red')
                if detect_data.shape[0] > 1:
                    print('WARNING: detection matches more than one template? num={}'.format(detect_data.shape[0]))
                    for i in range(detect_data.shape[0]):
                        print('... {}'.format(detect_data.iloc[i]))
            else:
                self.is_new = 1
                print('detection {} is not a template'.format(self.det_date))
                self.inCatalogValue.setText('event is new')
                self.inCatalogValue.setStyleSheet('color: green')
            # display the template location on a map
            location = (ev['longitude'], ev['latitude'], ev['depth'])
            self.region = str(ev['region'])
            self.evRegionValue.setText('{}'.format(self.region))
            self.magnitudeValue.setText('{:.1f}'.format(ev['mag']))
            self.mapMarker(location)
        else:
            print('{} not found'.format(imgName))
            self.messageBox.setText('image not found, click Next')
            self.messageBox.setStyleSheet('color: red')
        #print('changeImage: END')

    # TODO: if user clicks Prev or Next button, they want to review existing quality matches and not skip to next un-reviewed
    def clickPrev(self, button_click=False):
        '''
        Load previous image. Definition of previous depends on value of button_click.
        :param button_click: If True, user clicked button in UI. If False, this was called by another method.
        :return:
        '''
        #print('clickPrev: start')
        df = self.matchImages.getPrev()
        # TODO: must note if this is unseen or a review. Do not change region if review.
        if df.empty:
            print('clickPrev: empty df: reset to All regions')
            self.messageBox.setText('Reset to All: no more images in current region')
            self.regionSelect.setCurrentIndex(0)
        else:
            self.messageBox.setText('')
            self.imgName = df['filename']
            print('clickPrev: {}'.format(self.imgName))
            self.changeImage(self.imgName)
            self.setQualityButton(df['quality'])

    def clickNext(self, button_click=False):
        '''
        Load next image. Definition of next depends on value of button_click.
        If button_click==True, show next image even if already evaluated.
        If button_click==False, skip to next unevaluated image.
        :param button_click: If True, user clicked button in UI. If False, this was called by another method.
        :return:
        '''
        #print('clickNext: start')
        df = self.matchImages.getNext(view_seen=self.viewSeen, view_unseen=self.viewUnseen)
        # TODO: must note if this is unseen or a review. Do not change region if review.
        if df.empty:
            print('clickNext: empty df: reset to All regions')
            self.messageBox.setText('Reset to All: no more images in current region')
            self.regionSelect.setCurrentIndex(0)
        else:
            self.messageBox.setText('')
            self.imgName = df['filename']
            print('clickNext: {}'.format(self.imgName))
            self.changeImage(self.imgName)
            self.setQualityButton(df['quality'])

    def setQualityButton(self, value):
        # first make all buttons appear disabled
        for button in self.matchButtons:
            if button:
                button.setStyleSheet(DISABLE_STYLESHEET)
        if value == -1:
            return
        else:
            # reviewing an already evaluated image, so set the value button state
            if value == 4:
                self.saveGoodMatchButton.setStyleSheet(ENABLE_STYLESHEET)
            elif value == 3:
                self.saveMaybeMatchButton.setStyleSheet(ENABLE_STYLESHEET)
            elif value == 2:
                self.saveNotGoodMatchButton.setStyleSheet(ENABLE_STYLESHEET)
            elif value == 1:
                self.saveNoMatchButton.setStyleSheet(ENABLE_STYLESHEET)

    @timing
    def showImage(self, image_name):
        image_profile = QtGui.QImage(image_name)
        img_geom = self.image.geometry()
        image_profile = image_profile.scaled(img_geom.width(),img_geom.height(),
                                             aspectRatioMode=QtCore.Qt.KeepAspectRatio,
                                             transformMode=QtCore.Qt.SmoothTransformation) # To scale image for example and keep its Aspect Ration
        self.image.setPixmap(QtGui.QPixmap.fromImage(image_profile))

if __name__ == "__main__":
    stations = Stations()
    templates = EqTemplates()
    matchImages = MatchImages(IMAGE_DIR, templates, MATCH_RECORD_FILE)
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow(matchImages, stations, templates)
    window.show()
    retval = app.exec_()
    print('Exiting: {}'.format(retval))
    matchImages.save()
    sys.exit(retval)
